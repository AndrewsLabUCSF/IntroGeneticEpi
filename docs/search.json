[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Genetic Epidemiology",
    "section": "",
    "text": "Introduction\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "scripts/schedule.html#week-1-0422---0426",
    "href": "scripts/schedule.html#week-1-0422---0426",
    "title": "Schedule",
    "section": "Week 1 04/22 - 04/26",
    "text": "Week 1 04/22 - 04/26\n\nMonday 04/22\nAlzheimer’s disease\nIn this mini-course, we will frequently reference Alzheimer’s disease to illustrate various genetic epidemiology methods. This session aims to introduce Alzheimer’s disease and explore significant findings related to its genetic architecture.\nReadings\n\nKnopman, D. S. et al. Alzheimer disease. Nat Rev Dis Primers 7, 33 (2021).\nAlzheimer’s Association. 2023 Alzheimer’s disease facts and figures. Alzheimer’s Dementia (2023).\nKornblith, E. et al. Association of Race and Ethnicity With Incidence of Dementia Among Older Adults. Jama 327, 1488–1495 (2022).\nAndrews, S. J. et al. The complex genetic architecture of Alzheimer’s disease: novel insights and future directions. eBioMedicine 90, 104511 (2023).\nAndrews, S. J., Fulton-Howard, B. & Goate, A. Interpretation of risk loci from genome-wide association studies of Alzheimer’s disease. Lancet Neurology 19, 326–335 (2020).\n\n\n\nWensday 04/24\nGenome-Wide Association Studies\nGenome-Wide Association Studies (GWAS) are foundational to various genetic analysis methodologies. In this session, we will delve into what a GWAS entails, the process of conducting one, and then engage in a hands-on exercise to carry out our own GWAS.\nReadings\n\nUffelmann, E. et al. Genome-wide association studies. Nat Rev Methods Primers 1, 59 (2021).\nAbdellaoui, A., Yengo, L., Verweij, K. J. H. & Visscher, P. M. 15 years of GWAS discovery: Realizing the promise. Am J Hum Genetics (2023)\nMarees, A. T. et al. A tutorial on conducting genome‐wide association studies: Quality control and statistical analysis. Int J Method Psych 27, e1608 (2018).\nMacArthur, J. A. L. et al. Workshop proceedings: GWAS summary statistics standards and sharing. Cell Genom 1, 100004 (2021).\n\nTools\n\nPLINK1\nBCFTools2\nMungeSumStats3\n\n\n\nFriday 04/26\nGenetic Ancestry\nGenetic ancestry explores the lineage and heritage inferred from our DNA, providing insights into population history and individual heritage. This session will introduce the concepts and methodologies used in determining genetic ancestry, emphasizing their importance in genetic epidemiology research.\nReadings\n\nLewis, A. C. F. et al. Getting genetic ancestry right for science and society. Science 376, 250–252 (2022).\nNational Academies of Sciences, Engineering, and Medicine. 2023. Using Population Descriptors in Genetics and Genomics Research: A New Framework for an Evolving Field. Washington, DC: The National Academies Press.\n\nTools\n\nADMIXTURE4\nRFmix5"
  },
  {
    "objectID": "scripts/schedule.html#week-2-0429---0503",
    "href": "scripts/schedule.html#week-2-0429---0503",
    "title": "Schedule",
    "section": "Week 2 04/29 - 05/03",
    "text": "Week 2 04/29 - 05/03\n\nMonday 04/29\nHeritability & Genetic Correlations\nHeritability quantifies the proportion of phenotype variance attributable to genetic factors, whereas genetic correlations assess the extent of shared genetic architecture between traits. In this session, we will concentrate on the tools utilized to estimate these metrics from GWAS summary statistics.\nReadings\n\nRheenen, W. van, Peyrot, W. J., Schork, A. J., Lee, S. H. & Wray, N. R. Genetic correlations of polygenic disease traits: from theory to practice. Nat Rev Genetics 20, 567–581 (2019).\nBarry, C.-J. S. et al. How to estimate heritability: a guide for genetic epidemiologists. Int J Epidemiol (2022)\n\nTools\n\nLDSC6\nHDL7\nGenomicSEM8\n\n\n\nWensday 05/01\nPolygenic Risk Scores I\nPolygenic risk scores (PRS) measure an invididueals total genetic liability for a trait. This session will cover the process of constructing a PRS and assessing its performance in predicting the trait.\nReadings\n\nChoi, S. W., Mak, T. S.-H. & O’Reilly, P. F. Tutorial: a guide to performing polygenic risk score analyses. Nat Protoc 15, 2759–2772 (2020).\nWand, H. et al. Improving reporting standards for polygenic scores in risk prediction studies. Nature 591, 211–219 (2021).\nLennon, N. J. et al. Selection, optimization and validation of ten chronic disease polygenic risk scores for clinical implementation in diverse US populations. Nat. Med. 1–8 (2024)\n\nTools\n\nPRSice29\nPRSet10\n\n\n\nFriday 05/03\nPolygenic Risk Scores II\nThe accuracy of polygenic risk scores (PRS) diminishes as the genetic distance from the training population increases. This session will explore cross-ancestry PRS methods designed to enhance PRS accuracy across diverse populations.\nReadings\n\nKachuri, L. et al. Principles and methods for transferring polygenic risk scores across global populations. Nat. Rev. Genet. 1–18 (2023) doi:10.1038/s41576-023-00637-2.\nDing, Y. et al. Polygenic scoring accuracy varies across the genetic ancestry continuum. Nature 618, 774–781 (2023).\n\nTools\n\nPRS-CSx11"
  },
  {
    "objectID": "scripts/schedule.html#week-3-0506---0510",
    "href": "scripts/schedule.html#week-3-0506---0510",
    "title": "Schedule",
    "section": "Week 3 05/06 - 05/10",
    "text": "Week 3 05/06 - 05/10\n\nMonday 05/06\nMendelian Randomization I\nMendelian Randomization (MR) is a method employed to identify causal risk factors for diseases. This session will cover the fundamentals of MR and demonstrate how to execute a two-sample MR analysis.\nReadings\n\nSanderson, E. et al. Mendelian randomization. Nat Rev Methods Primers 2, 6 (2022).\nDavies, N. M., Holmes, M. V. & Smith, G. D. Reading Mendelian randomisation studies: a guide, glossary, and checklist for clinicians. BMJ 362, k601 (2017).\nHemani, G. et al. The MR-Base platform supports systematic causal inference across the human phenome. Elife 7, e34408 (2018).\n\nTools\n\nTwoSampleMR12\n\n\n\nWensday 05/08\nMendelian Randomization II\nA crucial aspect of Mendelian Randomization (MR) studies is assessing whether the causal associations derived from MR analyses remain valid despite potential violations of MR’s underlying assumptions. This session will focus on diagnostic and sensitivity analyses in MR, along with guidance on effectively reporting MR findings.\nReadings\n\nSkrivankova, V. W. et al. Strengthening the Reporting of Observational Studies in Epidemiology Using Mendelian Randomization. JAMA 326, 1614–1621 (2021).\nSkrivankova, V. W. et al. Strengthening the reporting of observational studies in epidemiology using mendelian randomisation (STROBE-MR): explanation and elaboration. BMJ 375, n2233 (2021).\n\n\n\nFriday 05/10\nTrainee Presentations\nUpon concluding this mini-course, trainees will showcase the results of their analyses.\n\n\n\n\n1. Purcell S, Neale B, Todd-Brown K, et al. PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses. The American Journal of Human Genetics. 2007;81(3):559-575.\n\n\n2. Danecek P, Bonfield JK, Liddle J, et al. Twelve years of SAMtools and BCFtools. GigaScience. 2021;10(2):giab008.\n\n\n3. Murphy AE, Schilder BM, Skene NG. MungeSumstats: A Bioconductor package for the standardisation and quality control of many GWAS summary statistics. Bioinformatics. 2021;37(23):btab665-.\n\n\n4. Alexander DH, Novembre J, Lange K. Fast model-based estimation of ancestry in unrelated individuals. Genome Research. 2009;19(9):1655-1664.\n\n\n5. Maples BK, Gravel S, Kenny EE, Bustamante CD. RFMix: A Discriminative Modeling Approach for Rapid and Robust Local-Ancestry Inference. The American Journal of Human Genetics. 2013;93(2):278-288.\n\n\n6. Bulik-Sullivan B, Finucane HK, Anttila V, et al. An atlas of genetic correlations across human diseases and traits. Nature Genetics. 2015;47(11):1236-1241.\n\n\n7. Ning Z, Pawitan Y, Shen X. High-definition likelihood inference of genetic correlations across human complex traits. Nature Genetics. 2020;52(8):859-864.\n\n\n8. Grotzinger AD, Rhemtulla M, Vlaming R de, et al. Genomic structural equation modelling provides insights into the multivariate genetic architecture of complex traits. Nature human behaviour. 2019;3(5):513-525.\n\n\n9. Choi SW, O’Reilly PF. PRSice-2: Polygenic Risk Score software for biobank-scale data. GigaScience. 2019;8(7).\n\n\n10. Choi SW, García-González J, Ruan Y, et al. PRSet: Pathway-based polygenic risk score analyses and software. PLOS Genetics. 2023;19(2):e1010624.\n\n\n11. Ruan Y, Lin YF, Feng YCA, et al. Improving polygenic prediction in ancestrally diverse populations. Nature Genetics. 2022;54(5):573-580.\n\n\n12. Hemani G, Zheng J, Elsworth B, et al. The MR-Base platform supports systematic causal inference across the human phenome. eLife. 2018;7:e34408."
  },
  {
    "objectID": "scripts/conda.html",
    "href": "scripts/conda.html",
    "title": "Conda Env",
    "section": "",
    "text": "#| eval: false\nname: genetic_epi\nchannels:\n  - conda-forge\n  - bioconda\ndependencies:\n  - plink=1.90b6.21\n#| eval: false\nconda env create -f env/genetic_epi.yml"
  },
  {
    "objectID": "scripts/habshd.html#phenotypes",
    "href": "scripts/habshd.html#phenotypes",
    "title": "HABS-HD",
    "section": "Phenotypes",
    "text": "Phenotypes\n\nlibrary(tidyverse)\nsetwd('~/gitcode/IntroGeneticEpi/')\nSAVE_VISUALIZATIONS_PATH <- \"results/figures\"\n#| code-fold: true\n\n\naa_v1_path = 'resources/HABSHD/v5/HD 1 African American 50+ Request 355.csv'\nma_v1_path = 'resources/HABSHD/v5/HD 1 Mexican American 50+ Request 355.csv'\nnhw_v1_path = 'resources/HABSHD/v5/HD 1 Non-Hispanic White 50+ Request 355.csv'\n\nhd_cols = spec(read_csv(nhw_v1_path, guess_max = 10000))\naa_v1.raw = read_csv(aa_v1_path, col_types = hd_cols,  na = c(\"\", \"NA\", \"9999\", \"-9999\", \"-8888\", \"-777777\", '-888888', '-999999')) %>%\n  janitor::clean_names() \nma_v1.raw = read_csv(ma_v1_path, col_types = hd_cols,  na = c(\"\", \"NA\", \"9999\", \"-9999\", \"-8888\", \"-777777\", '-888888', '-999999')) %>%\n  janitor::clean_names() \nnhw_v1.raw = read_csv(nhw_v1_path, col_types = hd_cols,  na = c(\"\", \"NA\", \"9999\", \"-9999\", \"-8888\", \"-777777\", '-888888', '-999999')) %>%\n  janitor::clean_names() \n\nhabshd.raw <- bind_rows(\n    aa_v1.raw, ma_v1.raw, nhw_v1.raw\n  ) %>%\n  mutate(\n    id_race_white = as.factor(id_race_white),\n    id_race_black = as.factor(id_race_black),\n    id_race_indian_alaska = as.factor(id_race_indian_alaska),\n    id_race_asian = as.factor(id_race_asian),\n    id_race_japanese = as.factor(id_race_japanese),\n    id_race_korean = as.factor(id_race_korean),\n    id_race_vietnamese = as.factor(id_race_vietnamese),\n    id_race_native_hawaiian = as.factor(id_race_native_hawaiian),\n    id_race_guam_chamorro = as.factor(id_race_guam_chamorro),\n    id_race_samoan = as.factor(id_race_samoan),\n    id_race_other_pacific = as.factor(id_race_other_pacific),\n    id_race_other = as.factor(id_race_other),\n    id_hispanic = as.factor(id_hispanic),\n    id_hispanic_other = as.factor(id_hispanic_other), \n    race = case_when(\n      id_hispanic != 1 ~ \"Hispanic\", \n      id_race_white == 1 & id_hispanic != 2 ~ \"NHW\", \n      id_race_black == 1 ~ \"Black\",\n      TRUE ~ \"Other\")\n  )\n\n\nhabshd <- habshd.raw %>%\n  mutate(\n    abeta40 = ifelse(is.na(r3_qtx_plasma_abeta42), r5_qtx_plasma_abeta40, r3_qtx_plasma_abeta40), \n    abeta42 = ifelse(is.na(r3_qtx_plasma_abeta42), r5_qtx_plasma_abeta42, r3_qtx_plasma_abeta42), \n    ptau181 = ifelse(is.na(r3_qtx_plasma_p_tau181), r5_qtx_plasma_p_tau181, r3_qtx_plasma_p_tau181), \n    total_tau = ifelse(is.na(r3_qtx_plasma_total_tau), r5_qtx_plasma_total_tau, r3_qtx_plasma_total_tau), \n    nfl = ifelse(is.na(r3_qtx_plasma_nf_l), r5_qtx_plasma_nf_l, r3_qtx_plasma_nf_l)\n  ) %>%\n  select(med_id, age, id_gender, interview_language, adi_state_rank, race, \n         id_education, smoke_ever, cdx_cog, cdx_depression,cdx_hypertension, \n         cdx_diabetes, cdx_dyslipidemia, cdr_sum, \n         om_bp1_dia, om_bp1_sys,\n         om_height, om_weight, om_bmi, om_ab_circumference,\n         bw_chol_total, bw_ld_lchol, bw_hdl_chol, bw_hba1c, gds_total,\n         abeta40, abeta42, ptau181, total_tau, nfl,\n         apoe4_snp\n         )\n\nwrite_csv(habshd, \"work/habshd_pheno.csv\")\n\n#descriptive table\ndescription <- c(\"Medical ID\",\"\",\"1 = Female <br> 0 = Male\",\n                 \"Language in which <br> interview was administered\", \n                 \"Area Deprivation Index\",'Black, Hispanic, NHW', \n                 \"Years of Education\",\"Ever Smoked<br> (1:Yes, 0:No)\",\n                \"Cognitive Disorder:<br> 0: Cognitively Unimpaired <br>1:Mild Cognitive   \n                 Impairment<br>2: Dementia\", \"Depression<br> (1:Yes, 0:No)\",\n                 \"Hypertension <br> (1:Yes,0:No)\", \"Diabetes <br> (1:Yes,0:No)\",\n                  \"High Cholesterol (1:Yes,0:No)\", \n                 \"Clinical Dementia Rating (CDR):<br> Sum of Boxes\", \n                 \"Diastolic BP\", \"Systolic BP\",  \"Height (in)\", \"Weight (lbs)\",\n                 \"BMI\", \"Abdominal circumference (in)\", \"Total Cholesterol\",\n                \"LDL Cholesterol<br> (bad)\",\"HDL Cholesterol<br> (good)\",\n                \"Hemoglobin\",\"Geriatric Depression Scale (GDS)\",\n                \"abeta40\",\"abeta42\",\"ptau181\", \"total_tau\",\"nfl\",\n                \"APOE Genotype\")\n                 \ntable_desc <- data.frame(cbind(names(habshd), description))\ntable_desc %>% kbl(caption = '', col.names = c(\"Variable\", \"Description\"),\n                   escape = FALSE) %>% \n  kable_classic(full_width = FALSE, html_font = \"Ariel\") %>% \n  kable_styling(font_size = 16, position = \"center\") %>% \n  column_spec(1:2, border_left = F, border_right = F) %>% \n  pack_rows(\"Demographics\",1,7) %>% \n  pack_rows(\"Clinical\",8,25) %>% \n  pack_rows(\"Imaging\",26,30) %>% \n  pack_rows(\"Genomics\",31,31) \n\n\nDescriptive Table\n\n\n\n\n\n\n\nVariable\nDescription\n\n\nDemographics\n\n\n\nmed_id\nMedical ID number\nNot an MRN\n\n\nage\nAge (yrs)\n\n\nid_gender\n1:Female\n0: Male\n\n\ninterview_language\nLanguage in which interview was administered\n1:English 2:Spanish\n\n\nadi_state_rank\nArea Deprivation Index\nLevels: 1,2,..,10\n1: least disadvantaged 10: most disadvantaged\n\n\nrace\nBlack, NHW, Hispanic\n\n\nid_education\nYears of Education\n\n\nClinical\n\n\n\nsmoke_ever\nEver smoked? 0:No 1:Yes\n\n\ncdx_cog\nCognitive Disorder\n0: Cognitively Unimpaired\n1:Mild Cognitive Impairment\n2: Dementia\n\n\ncdx_depression\nDepression 0:No 1:Yes\n\n\ncdx_hypertension\nHypertension 0:No  1:Yes\n\n\ncdx_diabetes\nDiabetes 0:No  1:Yes\n\n\ncdx_dyslipidemia.\nHigh Cholesterol 0:No 1:Yes\n\n\ncdr_sum\nClinical Dementia Rating (CDR)\nSum of Boxes\n\n\ngds_total\nGeriatric Depression Scale (GDS) sum of GDS 1 to GDS 30\n\n\nom_bp1_dia\nDiastolic BP\n\n\nom_bp1_sys\nSystolic BP\n\n\nom_height\nHeight (in)\n\n\nom_weight\nWeight (lbs)\n\n\nom_bmi\nBody Mass Index (BMI)\n\n\nom_ab_circumference\nAbdominal Circumference (in)\n\n\nbw_chol_total\nTotal Cholesterol (mg/dL)\n\n\nbw_ld_lchol\nLDL Cholesterol (mg/dL) (bad)\n\n\nbw_hdl_chol\nHDL Cholesterol (mg/dL) (good)\n\n\nbw_hba1c\nHemoglobin A1C% of total Hgb\n\n\nBiomarkers\n\n\n\nabeta40\n\\(A\\beta_{40}\\)\n\n\nabeta42\n\\(A\\beta_{42}\\)\n\n\nptau181\nPhospho-Tau (pg/mL)\nAverage CV: 0.07065\nAvgerage LLOD: 0.016\nAverage HLOD:349\n\n\ntotal_tau\nTotal Tau\n\n\nnfl\nNeurofilament Light (pg/mL)\nAverage CV: 0.038\nAvgerage LLOD: 0.038\nAverage HLOD:1800\n\n\nGenetics \n\n\n\napoe4_snp\nAPOE Genotype\nE2E3, E2E4, E3E3, E3E4, E4E4\n\n\n\n\nhabshd[which(habshd$adi_state_rank==\"GQ\"),] <- NA\nhabshd[which(habshd$adi_state_rank==\"PH\"),] <- NA\nhabshd[which(habshd$adi_state_rank==\"Invalid Address\"),] <- NA\nhabshd[which(habshd$smoke_ever==2),] <- NA\nhabshd$adi_state_rank <- as.integer(habshd$adi_state_rank)\n\ntheme_gtsummary_compact()\ndemographics_table <- habshd %>% select(age,id_gender,interview_language,\n                                          adi_state_rank, race, id_education) %>% \n                      tbl_summary(., by = race,\n                            statistic = list(\n                                    all_continuous() ~ \"{mean}<br> ({sd})\",\n                                    all_categorical()~ \"{p}%\"),\n                             digits = all_continuous()~2,\n                            label = c(age~\"Age\", id_gender ~ \"Gender\", \n                                      interview_language ~ \"Interview Language\",\n                                      adi_state_rank~ \"ADI State Rank\",\n                                      id_education~\"Education\"),\n                            missing_text = \"(Missing)\") %>%  \n                          modify_header(label = \"**Demographic <br> Variables**\",\n                          all_stat_cols() ~ \"**{level}**<br> N = {n}\") %>% \n                    as_gt() %>% \n                  tab_options(column_labels.border.top.color = \"black\",\n                              column_labels.border.bottom.color = \"black\",\n                              table_body.border.bottom.color = \"black\",\n                              table_body.hlines.color = \"white\",\n                              table.font.size = 12,\n                              container.width = 500, \n                              container.height =500) %>% \n                  fmt_markdown(columns = everything())\n\ngtsave(demographics_table,filename = file.path(SAVE_VISUALIZATIONS_PATH, \"demographics_summary.png\"))\n\n#convert to factors\ncdx_cols <- names(habshd %>% select(starts_with(\"cdx_\")))\nhabshd[cdx_cols] <-lapply(habshd[cdx_cols], factor)\n\nclinical_table1 <- habshd %>% select(smoke_ever,cdx_cog,cdx_depression,\n                                     cdx_hypertension,cdx_diabetes,\n                                     cdx_dyslipidemia,cdr_sum, om_bp1_dia,\n                                     race) %>% \n                  tbl_summary(., by = race, \n                              statistic = list(\n                                    all_continuous() ~ \"{mean} ({sd})\",\n                                    all_categorical()~ \"{p}%\"),\n                              digits = all_continuous()~2,\n                              label = c(smoke_ever ~ \"Smoke \",\n                                      cdx_cog ~ \"Cognitive Disorder\",\n                                      cdx_depression ~ \"Depression\",\n                                      cdx_hypertension ~ \"Hypertension\",\n                                      cdx_diabetes ~ \"Diabetes\",\n                                      cdx_dyslipidemia ~ \"Displedemia\",\n                                      cdr_sum ~ \"CDR Total Score\", \n                                      om_bp1_dia ~ \"Diastolic BP\"),\n                missing_text = \"(Missing)\") %>%  \n               modify_header(label = \"**Clinical Variables**\",\n                              all_stat_cols() ~ \"**{level}**<br> N = {n}\") %>% \n              as_gt() %>% \n              tab_options(\n                      column_labels.border.top.color = \"black\",\n                      column_labels.border.bottom.color = \"black\",\n                      table_body.border.bottom.color = \"black\",\n                      table_body.hlines.color = \"white\",\n                      table.font.size = 12,\n                      container.height = 700,\n                      container.width = 700) %>% \n              fmt_markdown(columns = everything()) \n\ngtsave(clinical_table1,filename = file.path(SAVE_VISUALIZATIONS_PATH, \"clinical_table1.png\"))\n\nclinical_table2 <- habshd %>% select(om_bp1_sys,om_height,om_weight,\n                                     om_bmi,om_ab_circumference,bw_chol_total,\n                                     bw_ld_lchol,bw_hdl_chol,race,bw_hba1c,\n                                     gds_total,race) %>% \n                   tbl_summary(., by = race, \n                              statistic = list(\n                                    all_continuous() ~ \"{mean} ({sd})\",\n                                    all_categorical()~ \"{p}%\"),\n                              digits = all_continuous()~2,\n                              label = c(om_bp1_sys~\"Systoliuc BP\",\n                                      om_height ~ \"Height (in)\", \n                                      om_weight~ \"Weight(lbs)\",\n                                      om_bmi ~\"BMI\",\n                                      om_ab_circumference~ \"Abdominal <br>\n                                      Circumference (in)\",\n                                      bw_chol_total ~ \"Total Cholesterol\",\n                                      bw_ld_lchol~ \"LDL <br> Cholesterol\", \n                                      bw_hdl_chol~ \"HDL <br> Cholesterol\",\n                                      bw_hba1c~ \"Hemoglobin\",\n                                      gds_total ~ \"GDS Total\"),\n                             missing_text = \"(Missing)\") %>%  \n                 modify_header(label = \"**Clinical <br> Variables**\",\n                              all_stat_cols() ~ \"**{level}**<br> N = {n}\") %>% \n                as_gt() %>% \n                tab_options(\n                        column_labels.border.top.color = \"black\",\n                        column_labels.border.bottom.color = \"black\",\n                        table_body.border.bottom.color = \"black\",\n                        table_body.hlines.color = \"white\",\n                        table.font.size = 12,\n                        container.height = 700,\n                        container.width = 700) %>% \n                fmt_markdown(columns = everything()) \ngtsave(clinical_table2,filename = file.path(SAVE_VISUALIZATIONS_PATH, \"clinical_table2.png\"))\n\nhabshd$apoe4_snp = as.factor(habshd$apoe4_snp)\nimaging_genetics_table <- habshd %>% select(abeta40, abeta42,ptau181, total_tau,\n                                            nfl, apoe4_snp,race) %>% \n                          tbl_summary(., by = race,\n                                      statistic = list(\n                                            all_continuous() ~ \"{mean} ({sd})\",\n                                            all_categorical()~ \"{p}%\"),\n                                      digits = all_continuous()~2,\n                                      label = c(abeta40~\"AB40\",\n                                                abeta42~\"AB42\",\n                                                ptau181 ~ \"pTau\", \n                                                total_tau ~ \"Total Tau\",\n                                                nfl~ \"Plasma NFL\", \n                                                apoe4_snp ~ \"APOE4 SNP\"),\n                                     missing_text = \"(Missing)\") %>%  \n                        modify_header(label = \"**Imaging & Genetic <br>\n                                      Variables**\",\n                                  all_stat_cols() ~ \"**{level}**<br> N = {n}\") %>% \n                        as_gt() %>% \n                        tab_options(\n                                column_labels.border.top.color = \"black\",\n                                column_labels.border.bottom.color = \"black\",\n                                table_body.border.bottom.color = \"black\",\n                                table_body.hlines.color = \"white\",\n                                table.font.size = 12, \n                                container.width = 700, \n                                container.height =700) %>% \n                      fmt_markdown(columns = everything())\n\ngtsave(imaging_genetics_table,filename = file.path(SAVE_VISUALIZATIONS_PATH, \"imaging_genetic_table.png\"))"
  },
  {
    "objectID": "scripts/habshd.html#genotyping",
    "href": "scripts/habshd.html#genotyping",
    "title": "HABS-HD",
    "section": "Genotyping",
    "text": "Genotyping\nTBD\n\nHapMap III\nDownload the hapmap_3.3.hg38.vcf.gz file from the Broad’s google bucket\n\nbcftools view -i 'AF > 0 && TYPE=\"snp\" && N_ALT=1' resources/genetic_epi/resources_broad_hg38_v0_hapmap_3.3.hg38.vcf | \\\nbcftools view -H > work/hapmap3_snps.txt\n\n\nhm3.raw <- read_table(\"work/hapmap3_snps.txt\", col_names = F)\n\nhm3 <- hm3.raw %>%\n  mutate(\n    cpra = glue::glue(\"{X1}:{X2}:{X4}:{X5}\"), \n    X1 = as.numeric(str_replace(X1, 'chr', ''))\n  ) %>%\n  filter(!is.na(X1)) %>%\n  rename(chr = X1, pos = X2, rsid = X3, ref = X4, alt = X5) %>%\n  select(-X6)\n\nout <- hm3 %>% \n  distinct(cpra, .keep_all = T) %>%\n  distinct(rsid, .keep_all = T) \n\nout %>% \n  select(cpra) %>%\n  write_tsv(., 'work/hm3_extract.txt', col_names = F) \n\nout %>% \n  select(cpra, rsid) %>%\n  write_tsv(., 'work/hm3_crpa_rsid.txt', col_names = F) \n\n\nplink \\\n  --bfile resources/HABSHD/genotypes/all \\\n  --keep-allele-order \\\n  --extract work/hm3_extract.txt \\\n  --make-bed \\\n  --out work/habshd_hm3\n\nplink \\\n  --bfile work/habshd_hm3 \\\n  --keep-allele-order \\\n  --update-name work/hm3_crpa_rsid.txt \\\n  --make-bed \\\n  --out work/habshd_rsid"
  },
  {
    "objectID": "scripts/gwas_qc.html#snp-qc",
    "href": "scripts/gwas_qc.html#snp-qc",
    "title": "GWAS QC",
    "section": "SNP QC",
    "text": "SNP QC\nSNP level QC consists of removing markers with excessive missingness or low allele frequency. This QC increases the power to identify true associations with disease risk by removing suboptimal markers that can increase false positives.\n\nCall Rate & Allele frequency\n95% was used as the SNP call rate threshhold (usually ≥ 95% or higher), and 1% was used as the MAF threshold (usually ≥ 1% or higher). \nFiltering SNPs on MAF and call rate can be done in PLINK 1.9 by typing the following (or similar) at the shell prompt. This uses 95% and 1% for the call-rate and MAF, respectively:\n\n# Generate frequency reports\nplink \\\n    --bfile work/habshd_rsid \\\n    --keep-allele-order \\\n    --freq \\\n    --out work/habshd_snpqc  \n\nplink \\\n    --bfile work/habshd_rsid \\\n    --keep-allele-order \\\n    --freqx \\\n    --out work/habshd_snpqc  \n\n# Filter on call rate and maf\nplink \\\n    --bfile work/habshd_rsid \\\n    --keep-allele-order \\\n    --geno 0.05 --maf 0.01 \\\n    --make-bed --out work/habshd_snpqc  \n\n\n## ==== SNP Level Filtering ====\n# ---- readin plink .frq ---- ##\nmessage(\"reading plink frq file\")\nfreq.raw <- read_table('work/habshd_snpqc.frq', col_names = T,\n  col_types = cols(\n  CHR = col_double(),\n  SNP =col_character(),\n  A1 = col_character(),\n  A2 = col_character(),\n  MAF = col_double(),\n  NCHROBS = col_double()\n))\n\n# ---- readin plink .frqx ---- ##\nmessage(\"reading plink frqx file\")\nfreqx.raw <- read_tsv('work/habshd_snpqc.frqx', col_names = T,\n  col_types = cols(\n  CHR = col_double(),\n  SNP = col_character(),\n  A1 = col_character(),\n  A2 = col_character(),\n  `C(HOM A1)` = col_double(),\n  `C(HET)` = col_double(),\n  `C(HOM A2)` = col_double(),\n  `C(HAP A1)` = col_double(),\n  `C(HAP A2)` = col_double(),\n  `C(MISSING)` = col_double()\n))\n\n# ---- SNP level statisitcs ----\nsnps <- freq.raw %>%\n  full_join(freqx.raw, by = c(\"CHR\", \"SNP\", \"A1\", \"A2\")) %>%\n  rename(AA = `C(HOM A1)`, AB = `C(HET)`, BB = `C(HOM A2)`, missing = `C(MISSING)`) %>%\n  mutate(Call.rate = 1 - (missing / c(AA + AB + BB + missing))) %>%\n  mutate(Call = Call.rate >= 1 - 0.05) %>%\n  mutate(Call.maf = MAF < 0.01) \n\nFigure @ref(fig:MAFxcallrate) shows the SNP call rate versus minor allele frequncy across all typed SNPs in the study. The dashed lines denote the MAF and call rate QC thresholds. xxx SNPs were removed due to low call rate and xxx SNPs were removed due to low minor allele frequency.\n\nMAFxcallrate.p <- ggplot(data = snps, aes(x = MAF, y = Call.rate)) +\n  geom_point(alpha = 0.3, size = 0.5) +\n  geom_hline(yintercept = 1 - 0.05, linetype = 2, colour = 'red') +\n  geom_vline(xintercept = 0.01, linetype = 2, colour = 'red') +\n  scale_x_log10(breaks = scales::trans_breaks(\"log10\", function(x) round(10^x, 3))) +\n  labs(y = 'Proportion of called genotypes', x = 'Minor Allele Frequency (log)') +\n  theme_bw() + annotation_logticks()\n\nggsave('results/plots/MAFxcallrate.png', plot = MAFxcallrate.p, height = 4, width = 6, units = 'in')\n\n\n\nHardy Weinberg Equilibrium\nViolations of Hardy Weinberg Equilibrium can indicate either the presence of population substructure, or the occurence of genotyping error. It is common practice to assume that violoations are indicative of genotyping error and remove SNPs in which the HWE test statistic has a corresponding p-value of less then 1x10-6. A threshold of xxx is used here.\nFor case-control data, HWE is generally not tested in cases to not exclude real selection against a phenotype, so it is best to include case-control status in the PLINK files.\n\nFiltering SNPs on Hardy Weinberg Equilibrium for autosomes only can be done in PLINK by typing the following at the shell prompt:\n\nplink \\\n    --bfile work/habshd_snpqc  \\\n    --keep-allele-order \\\n    --autosome \\\n    --hardy \\\n    --hwe 0.000001 \\\n    --make-bed --out work/habshd_hwe\n\n\n# ---- readin plink .hwe ---- ##\nmessage(\"reading plink hwe file\")\nhwe.raw <- read_table2('work/habshd_hwe.hwe', col_types = cols(\n  CHR = col_integer(),\n  SNP = col_character(),\n  TEST = col_character(),\n  A1 = col_character(),\n  A2 = col_character(),\n  GENO = col_character(),\n  `O(HET)` = col_double(),\n  `E(HET)` = col_double(),\n  P = col_double()\n))\n\nsnps <- snps %>%\n  full_join(hwe.raw, by = c(\"CHR\", \"SNP\", \"A1\", \"A2\")) %>%\n  mutate(hwe = P > 0.000001) %>%\n  as_tibble()\n\nsuppressPackageStartupMessages(library(ggtern))\n\nhweplot <- snps %>%\n  filter(!is.na(P)) %>%\n  mutate(alph = ifelse(hwe, 0.2, 0.8),\n         hwe = ifelse(hwe, \"Pass\", \"Fail\")) %>%\n  ggtern::ggtern(aes(x = AA, y = AB, z = BB, colour = hwe, alpha = alph)) +\n   geom_point(size = 0.5)  +\n   scale_colour_manual(name= 'Hardy Weinberg \\n Equilibrium',\n                       values = c(Pass = \"#377EB8\", Fail = \"#E41A1C\")) +\n   scale_alpha_continuous(guide = \"none\", range = c(0.8, 0.2)) +\n   theme_bw() + theme(legend.position = 'bottom')\n\nhweplot\n\ndetach(\"package:ggtern\", unload=TRUE)\n\nggsave('results/plots/hweplot.png', plot = hweplot, height = 4, width = 6, units = 'in')"
  },
  {
    "objectID": "scripts/gwas_qc.html#sample-qc",
    "href": "scripts/gwas_qc.html#sample-qc",
    "title": "GWAS QC",
    "section": "Sample QC",
    "text": "Sample QC\n\nCall Rate\nA low genotyping call rate in a sample can be indicative of poor DNA sample quality, so samples with a call rate < xxx% are excluded from further analysis. \nFiltering samples on a call rate of 95% can be done in PLINK by typing the following at the shell prompt:\n\nplink \\\n    --bfile work/habshd_hwe \\\n    --keep-allele-order \\\n    --mind 0.05 \\\n    --make-bed --out work/habshd_sampleQC\n\n\n\nSex Discordance\nSamples with discordance between self-reported and genetically predicted sex likely have errors in sample handling, such as sample swaps. Predicted sex can be determined by calculating X chromosome heterozygosity using an F test, because biological men have one X chromosome and women have two. An F value of ~0.99 indicates males, and an F value of ~0.03 indicates females. Furthermore, checking X chromosome heterozygosity may reveal sex chromosome anomalies (~0.28 in reported females; ~0.35 in males).\nSince sex discordance may be due to sample swaps or to incorrect phenotyping, sex discordant samples should generally be removed unless a swap can be reliably resolved.\nIdentification of individuals with discordent sex can be done in PLINK 1.9 by typing the following at the shell prompt, which will produce a list of individuals with discordent sex data.\n\nplink \\\n    --bfile resources/HABSHD/genotypes/HABLE_GSA_20230418a_FINAL  \\\n    --check-sex --out work/HABLE_GSA_20230418a\n\nplink \\\n    --bfile resources/HABSHD/genotypes/HABLE_GSA_20220602_FINAL  \\\n    --check-sex --out work/HABLE_GSA_20220602\n\nawk 'FNR==1 && NR==1 {print; next} FNR>1 {print}' work/HABLE_GSA_20220602.sexcheck work/HABLE_GSA_20230418a.sexcheck > work/habshd_sexcheck.txt\n\n\n## ---- Read in Data ----##\nsexcheck.raw <- read_table('work/habshd_sexcheck.txt')\n\n##  recode sex varibles\nsexcheck <- sexcheck.raw %>%\n  mutate(PEDSEX = recode(PEDSEX, '2' = 'Female', '1' = 'Male'))\n\n##  Exclude samples with no sex inconsistencies\nsex_exclude.samples <- sexcheck %>%\n  filter(STATUS == 'PROBLEM') %>%\n  mutate(PEDSEX = recode(PEDSEX, '2' = 'Female', '1' = 'Male'))\n\nThe following plot (Fig. @ref(fig:sexplot)) displays the X Chromosome heterozygosity for self reported sex, with samples with problems highlighted in red. Table @ref(tab:sextab) displays the individule records that should be excluded from further downstream analysis.\n\nsexcheck.p <- ggplot(data = sexcheck, aes(x = as.factor(PEDSEX), y = F, colour = STATUS, shape = STATUS)) +\n  geom_jitter() +\n  scale_color_manual(values = c( \"#377EB8\", \"#E41A1C\")) +\n  theme_bw() + labs(x = 'Self reported sex', y = 'X CHR Heterozygocity (F)') + theme(legend.position=\"bottom\")\n\nggsave('results/plots/sexcheck.png', plot = sexcheck.p, height = 4, width = 6, units = 'in')\n\n\n\nPruning\nPruning is typically done to remove linkage disequilibrium (LD) between SNPs, which is often a necessary step in various genetic analyses to ensure the independence of markers and is necessary for estimating heterozygosity, realtedness, and population stratification.\n\nplink \\\n  --bfile work/habshd_sampleQC \\\n  --indep-pairwise 50 5 0.2 \\\n  --out work/indepSNP\n\n\n\nHeterozygosity check\nInsufficient heterozygosity can indicate inbreeding or other family substructures, while excessive heterozygosity may indicate poor sample quality.\nIndividuals with outlying heterozygosity rates can be identified in PLINK 1.9 by typing the following command at the shell prompt:\n\nplink \\\n    --bfile work/habshd_sampleQC  \\\n    --extract work/indepSNP.prune.in \\\n    --het --out work/habshd\n\nThis produces a file containing Method-of-moments F coefficient estimates, which can be used to calculate the observed heterozygosity rate in each individual. Analysis is performed using an LD pruned snplist.\nWe calculate a heterozygocity similarly using observed and expected counts from the PLINK output [(Observed - Expected)/N) and exclude samples that are ± 3 sd from the cohort mean. \n\n## ---- Read in Data ----##\nhet.raw <- read_table('work/habshd.het')\n\n## caluclate heterozygosity\nhet <- het.raw %>%\n  rename(O = `O(HOM)`, E = `E(HOM)`, N = `N(NM)`) %>%\n  mutate(Het = (N - O) / N)\n\n##  Calculate exclusion thresholds\nupper.het <- mean(het$Het) + sd(het$Het)*3\nlower.het <- mean(het$Het) - sd(het$Het)*3\n\n##  Exclusion of samples\nhet <- het %>%\n  mutate(exclude = ifelse(Het >= upper.het | Het <= lower.het, TRUE, FALSE))\n\nhet_exclude.samples <- het %>% filter(exclude == TRUE)\n\nFigure @ref(fig:plothet) displays the distrubution of heterozygosity in xxx. Samples with excessive (Het > xxx) or deficient (Het < xxx) heterozygosity are colored red. Table @ref(tab:het) displays samples that are to be excluded.\n\nheterozygosity.p <- ggplot(het, aes(x = Het, fill = exclude)) + geom_histogram(binwidth = 0.001) +\n  geom_vline(xintercept = upper.het, colour = 'red', linetype = 2) +\n  geom_vline(xintercept = lower.het, colour = 'red', linetype = 2) +\n  theme_bw() + scale_fill_manual(values = c(\"#377EB8\", \"#E41A1C\")) +\n  theme(legend.position = 'bottom') +\n  labs(x = 'Heterozygosity')\n\nggsave('results/plots/heterozygosity.png', plot = heterozygosity.p, height = 4, width = 6, units = 'in')\n\n\n\nCryptic Relatedness\nPopulation based cohorts are often limited to unrelated individuals as associations statistics often assume independence across individuals. Closely related samples will share more of their genome and are likely to be more phenotypically similar than than two individuals chosen randomly from the population. A common measure of relatedness is identity by descent (IBD), where a kinship correlation coefficient (pi-hat) greater 0.1 suggests that samples maybe related or duplicates samples.\n\n# IBD relationship table\n# https://github.com/WheelerLab/GWAS_QC/blob/master/example_pipelines/QC%20Analysis%20-%20Cox%20Lab%20Projects.pdf\n\nrel_tab <- tibble(relationship = c(\"unrelated\", \"identical-twins\",\n                                   \"parent-child\", \"full-siblings\",\n                                   \"half-siblings\", \"grandparent-grandchild\",\n                                   \"avuncular\", \"half-avuncular\",\n                                   \"first-cousin\", \"half-first-cousin\",\n                                   \"half-sibling-first-cousin\"),\n  pi_hat = c(0, 1, 0.5, 0.5, 0.25, 0.25, 0.25, 0.125, 0.125, 0.0625, 0.375),\n  z0 = c(1, 0, 0, 0.25, 0.5, 0.5, 0.5, 0.75, 0.75, 0.875, 0.375),\n  z1 = c(0, 0, 1, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.125, 0.5),\n  z2 = c(0, 1, 0, 0.25, 0, 0, 0, 0, 0, 0, 0.125)\n)\n\ndup_relationships <- c(\"grandparent-grandchild\", \"avuncular\", \"half-avuncular\")\nrel_tab_filt <- rel_tab %>%\n  filter(relationship %nin% dup_relationships) %>%\n  mutate(relationship = ifelse(relationship == \"half-siblings\", \"2nd degree\",\n                               ifelse(relationship == \"first-cousin\",\n                                      \"3rd degree\", relationship)))\n\nIdentifying duplicated or related samples can be done in PLINK 1.9 by typing the following command at the shell prompt.\n\nplink \\\n    --bfile work/habshd_sampleQC \\\n    --extract work/indepSNP.prune.in \\\n    --genome --min 0.05 --out work/habshd.ibd\n\n\n# select samples with kinship cofficents > 0.1875\n# https://link.springer.com/protocol/10.1007/978-1-60327-367-1_19\npi_hat_thres = 0.1875\n\n# Find closest match\nclosest <- function(vals, ref) {\n  fc <- Vectorize(function(x) {\n    ref[which.min(abs(ref - x))]\n  }) #finds closest\n  fc(vals)\n}\n\n# Iteratively Remove related samples\nremove_samples <- function(ibdcoeff, fam, msg = \"closely related to\") {\n  fam_fi <- fam %>%\n    mutate(FI = paste0(FID, \"_-_-tempsep-_-_\", IID)) %>%\n    mutate(status = ifelse(status > 2, 0.5, status))\n\n  ibdcoeff %<>%\n    mutate(FI1 = paste0(FID1, \"_-_-tempsep-_-_\", IID1),\n           FI2 = paste0(FID2, \"_-_-tempsep-_-_\", IID2))\n  related_samples <- NULL\n  excluded <- c()\n  fam_table <- tibble(FID = c(\"deleteme\"),\n                      IID = c(\"deleteme\"),\n                      Related = c(\"deleteme\"))\n  while (nrow(ibdcoeff) > 0) {\n    test_tab <- plyr:::count(c(ibdcoeff$FI1, ibdcoeff$FI2))\n    if (!(\"x\" %in% names(test_tab))) {\n      print(ibdcoeff)\n    }\n    sample.counts <- plyr:::count(c(ibdcoeff$FI1, ibdcoeff$FI2)) %>%\n      as_tibble %>%\n      rename(FI = x) %>%\n      mutate(FI = as.character(FI)) %>%\n      inner_join(fam_fi, by = \"FI\") %>%\n      arrange(desc(qc_failed), status, desc(freq))\n    rm.sample <- sample.counts[[1, \"FI\"]]\n    id_ <- str_split(rm.sample, \"_-_-tempsep-_-_\")[[1]]\n    fid <- id_[1]\n    iid <- id_[2]\n    remtxt <- sprintf(\"%s %i other samples.\",\n                      msg,\n                      sample.counts[[1, \"freq\"]])\n    message(paste(\"Removing sample\", iid, remtxt))\n    ft <- tibble(FID = fid, IID = iid, Related = remtxt)\n    fam_table <- fam_table %>%\n      bind_rows(ft)\n    ibdcoeff <- ibdcoeff[ibdcoeff$FI1 != rm.sample &\n                           ibdcoeff$FI2 != rm.sample, ]\n    related_samples <- c(as.character(rm.sample), related_samples)\n  }\n  return(\n    list(related_samples = related_samples,\n         fam_table = filter(fam_table, Related != \"deleteme\"),\n         exclude_samples = tibble(FI = as.character(related_samples)) %>%\n           separate(FI, c(\"FID\", \"IID\"), sep = \"_-_-tempsep-_-_\")))\n}\n\n\n# Import data \nfam <- \"work/habshd_sampleQC.fam\" %>%\n  read_table(col_types = \"cc---i\", col_names = c(\"FID\", \"IID\", \"status\")) %>%\n  mutate(qc_failed = FALSE)\n\nrelatedness.raw = read_table(\"work/habshd_ibd.genome\") \n\nibdcoeff <- relatedness.raw %>%\n  filter(PI_HAT > pi_hat_thres) %>%\n  mutate(\n    pi_hat = closest(PI_HAT, rel_tab_filt$pi_hat),\n    z0 = closest(Z0, rel_tab_filt$z0),\n    z1 = closest(Z1, rel_tab_filt$z1),\n    z2 = closest(Z2, rel_tab_filt$z2),\n  ) %>%\n  left_join(rel_tab_filt) \n\nibdcoeff_unrelated <- remove_samples(ibdcoeff, fam)\n\nThe following histogram (Fig. @ref(fig:kinplot)) shows the distribution of proportion of IBD sharing (pi-hat in PLINK; PropIBD in KING) between all pairs.\n\nggplot(relatedness.raw, aes(x = PI_HAT)) +\n  geom_histogram(binwidth = 0.01, fill = \"#377EB8\") +\n  scale_y_continuous(trans = 'log10', breaks = scales::trans_breaks(\"log10\", function(x) round(10^x, 3))) + \n  coord_cartesian(xlim = c(min(relatedness.raw$PI_HAT) - 0.05, 1)) +\n  annotation_logticks() + \n  theme_bw() + \n  labs(x = \"IBD Sharing (pi-hat in PLINK)\") +\n  geom_vline(xintercept = pi_hat_thres,\n             colour = \"red\", linetype = 2)\n\nggsave(\"results/plots/ibd.png\", width = 4, height = 4, units = 'in')\n\nThe following plot (Fig. @ref(fig:relplot)) shows the xxx by the proportion of loci where individuals share zero alleles (Z0), where the proportion of IBD sharing is greater than 0.05. In family based studies, pairs are colored by IBD relationship. Table @ref(tab:ibdfail) displays the individuals where the kinship coefficient was greater than xxx in population based studies OR how were duplicates in family based studies.\n\nggplot(ibdcoeff, aes(x = Z0, y = Z1, color = relationship)) + \n  geom_point() + \n  labs(x = 'P(IBD=0)', y = \"P(IBD=0)\") + \n  theme_bw()\n\nggsave(\"results/plots/relatedness.png\", width = 6, height = 4, units = 'in')\n\n\n\nPopulation Substructure\nAfter excluding population outliers from the dataset, population substructure will remain due to the presence of genetic diversity within apparently homogenous populations. Within a single ethnic population, even subtle degrees of population stratification can bias results due to differences in allele frequencies between subpopulations. Principal components based on the observed genotypes in the dataset of interest can be used to capture information on substructure and be included as covariates in downstream analysis.\nTo obtain the principal components for the sample dataset after population outliers have been removed, type the following PLINK 1.9 commands at the shell prompt to generate the principal component eigenvalue and eigenvector files.\n\nplink \\\n    --bfile work/habshd_sampleQC \\\n    --extract work/indepSNP.prune.in \\\n    --pca 10 \\\n    --out work/habshd\n\n\n# PCA file from plink\n\nzscore = function(x){(x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)}\n\n# Read in eigenvectors and z-score transform\npca <- read_delim('work/habshd.eigenvec', \n                  delim = \" \", col_names = c(\"FID\", \"IID\", paste0(\"PC\", 1:10)),\n                  col_types = cols(.default = \"d\", FID = \"c\", IID = \"d\")) %>%\n         mutate_at(paste0(\"PC\", 1:10), zscore) %>%\n  left_join(habshd %>% select(med_id, race), by = c('IID' = \"med_id\"))\n\n# read in egienvalues\neigenval.raw <- parse_number(read_lines('work/habshd.eigenval'))\n\neigenval <- tibble(eigenval = eigenval.raw,\n                   PC = 1:length(eigenval.raw)) %>%\n              mutate(PVE = round(eigenval / sum(eigenval), 3)) %>%\n              select(PC, eigenval, PVE)\n\n\n\nScree Plot\nThe below scree plot (Fig. @ref(fig:ScreePlotStrat)) shows the amount of variation retained by each principal component (Left) and the cumualtive proportion of variance explained by each principal compoent (Right).\n\n#Include the number of PC for where the cumualtive PVE is 95%\nPC.inc <-  findInterval(0.95, cumsum(eigenval$PVE)) + 1\n\n## ---- Plot scree plot of proportion of varaince explained by Principal components ---- ##\np1 <- ggplot(data = eigenval, aes(x = PC, y = PVE, group = factor(1))) +\n  geom_point(colour = '#377EB8') + geom_path(colour = '#377EB8') +\n  scale_x_continuous(breaks = c(1:10)) + \n  labs(x = 'Principal Components') +\n  theme_bw() + coord_cartesian(ylim = c(0,1), default = T)\n\n\np2 <- ggplot(data = eigenval, aes(x=PC, y=cumsum(PVE), group = factor(1))) +\n  geom_point(colour = '#377EB8') + geom_path(colour = '#377EB8') +\n  scale_x_continuous(breaks = c(1:10)) + \n  labs(x = 'Principal Components', y = 'cumulative PVE') +\n  theme_bw() + coord_cartesian(ylim = c(0,1), default = T) +\n  geom_hline(yintercept = 0.95, colour = '#E41A1C', linetype = 2)\n\np3 <- gridExtra::grid.arrange(p1, p2, ncol = 2)\n\nggsave(\"results/plots/screeplot.png\", plot = p3, width = 9, height = 4, units = 'in')\n\n\n\nPopulation substructure\nThe following plots show the population structure of xxx based on the first two (Fig. @ref(fig:2PCstrat)) and three (Fig. @ref(fig:3PCstrat))) principal components compared with the reference populations from 1000 Genomes.\n\n##  Plot Superpopulations, PC1 + PC2\nggplot(pca, aes(x = PC2, y = PC1, color = race)) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") + \n  theme_bw() + theme(legend.position = 'right')\n\nggsave(\"results/plots/pca.png\", width = 6, height = 4, units = 'in')\n\n\n\nExclude Samples\n\nbind_rows(\n  sex_exclude.samples, \n  het_exclude.samples,\n  ibdcoeff_unrelated$exclude_samples %>% mutate_at(c('FID', 'IID'), as.numeric)\n) %>%\n  select(FID, IID) %>%\n  distinct(FID, IID) %>%\n  write_tsv('work/habshd.ExcludeSamples.tsv', col_names = F)\n\n\nplink \\\n    --bfile work/habshd_sampleQC \\\n    --keep-allele-order \\\n    --remove work/habshd.ExcludeSamples.tsv \\\n    --make-bed --out work/habshd_gwas"
  },
  {
    "objectID": "scripts/gwas.html#import",
    "href": "scripts/gwas.html#import",
    "title": "GWAS",
    "section": "Import",
    "text": "Import\n\nfam <- read_table('work/habshd_gwas.fam', col_names = c('FID', 'IID'))\nhabshd <- read_csv(\"work/habshd_pheno.csv\") %>% distinct(med_id, .keep_all = T)\npc <- pca <- read_delim('work/habshd.eigenvec', \n                  delim = \" \", col_names = c(\"FID\", \"IID\", paste0(\"PC\", 1:10)),\n                  col_types = cols(.default = \"d\", FID = \"c\", IID = \"d\"))"
  },
  {
    "objectID": "scripts/gwas.html#phenotype-file",
    "href": "scripts/gwas.html#phenotype-file",
    "title": "GWAS",
    "section": "Phenotype File",
    "text": "Phenotype File\n\npheno <- fam %>%\n  left_join(select(habshd, med_id, cdr_sum), by = c('IID' = 'med_id')) \n\npheno %>%\n  write_tsv('work/habshd_gwas.pheno', col_names = F)"
  },
  {
    "objectID": "scripts/gwas.html#covariate-file",
    "href": "scripts/gwas.html#covariate-file",
    "title": "GWAS",
    "section": "Covariate File",
    "text": "Covariate File\n\ncovar <- fam %>%\n  left_join(select(habshd, med_id, age, id_gender), by = c('IID' = 'med_id')) %>%\n  left_join(select(pc, IID, PC1, PC2, PC3, PC4), by = 'IID') \n\ncovar %>%\n  write_tsv('work/habshd_gwas.covar', col_names = F)"
  },
  {
    "objectID": "scripts/gwas.html#gwas",
    "href": "scripts/gwas.html#gwas",
    "title": "GWAS",
    "section": "GWAS",
    "text": "GWAS\n\nplink \\\n  --bfile work/habshd_gwas \\\n  --pheno work/habshd_gwas.pheno \\\n  --covar work/habshd_gwas.covar \\\n  --linear hide-covar \\\n  --out results/habshd_cdr_gwas"
  },
  {
    "objectID": "scripts/gwas.html#manhattan-plot",
    "href": "scripts/gwas.html#manhattan-plot",
    "title": "GWAS",
    "section": "Manhattan Plot",
    "text": "Manhattan Plot\n\ngwas.raw <- read_table('results/habshd_cdr_gwas.assoc.linear') %>%\n  select(-X10)\n\ngwas.raw %>% arrange(P)\n\ncdr_gwas.p <- ggman::ggman(gwas.raw, snp = \"SNP\", bp = \"BP\", chrom = \"CHR\", pvalue = \"P\", relative.positions = TRUE) + \n  theme_classic()\n\nggsave(\"results/plots/cdr_gwas.png\", plot = cdr_gwas.p, width = 9, height = 4, units = 'in')"
  },
  {
    "objectID": "scripts/gwas_ss.html#ad-gwas",
    "href": "scripts/gwas_ss.html#ad-gwas",
    "title": "GWAS-SS",
    "section": "AD GWAS",
    "text": "AD GWAS\nWe download the International Genomics of Alzheimer’s Project (IGAP) Alzheimer’s disease GWAS of Kunkle et al. Nat Genet, 2019. from the GWAS catalouge. These summary statistics correspond to the meta-analysis results obtained in stage 1 including genotyped and imputed data (11,480,632 variants, phase 1 integrated release 3, March 2012) of 21,982 Alzheimer’s disease cases and 41,944 cognitively normal controls.\nThe Summary statistics consists of the following information for each SNP and its association to Alzheimer’s disease based on meta-analysis in the publication mentioned below.\n\nChromosome: Chromosome of the SNP (Build 37, Assembly Hg19)\nPosition: Position of the SNP (Build 37, Assembly Hg19)\nMarkerName: SNP rsID or chromosome:position:I/D if rsID not available. I/D indicates indel or deletion respectively.\nEffect_allele: Reference allele (coded allele)\nNon_Effect_allele: Non reference allele (non coded allele)\nBeta: Overall estimated effect size for the effect allele\nSE: Overall standard error for effect size estimate\nPvalue: Meta-analysis Pvalue using regression coefficients (beta and standard error)\n\n\ncurl https://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/GCST007001-GCST008000/GCST007511/Kunkle_etal_Stage1_results.txt > resources/Kunkle_etal_Stage1_results.txt"
  },
  {
    "objectID": "scripts/gwas_ss.html#mungesumstats",
    "href": "scripts/gwas_ss.html#mungesumstats",
    "title": "GWAS-SS",
    "section": "MungeSumstats",
    "text": "MungeSumstats\nThe MungeSumstats package is designed to facilitate the standardization of GWAS summary statistics.\n\nlibrary(tidyverse)\n\n\nload.raw <- read_table('resources/Kunkle_etal_Stage1_results.txt')\n\nload <- load.raw %>%\n  filter(nchar(Effect_allele) == 1 & nchar(Non_Effect_allele) == 1) %>%\n  mutate(\n    Ncaas = 21982,\n    Nctrl = 41944,\n    N = 63926\n  )\n\nreformatted <- \n  MungeSumstats::format_sumstats(path=load,\n                                 ref_genome=\"GRCh37\", \n                                 dbSNP = 144, \n                                 return_data = TRUE\n                                 ) %>%\n  as_tibble()\n\nwrite_tsv(reformatted, 'work/Kunkle2019load.tsv.gz')"
  },
  {
    "objectID": "scripts/gwas_ss.html#manhattan-plot",
    "href": "scripts/gwas_ss.html#manhattan-plot",
    "title": "GWAS-SS",
    "section": "Manhattan Plot",
    "text": "Manhattan Plot\n\nload.df_p <- reformatted %>%\n  filter(., P < 0.1) %>% \n  filter(., P > 1e-50) %>% \n  select(SNP, CHR, BP, P) \n\ndon <- load.df_p %>% \n  \n  # Compute chromosome size\n  group_by(CHR) %>% \n  summarise(chr_len=max(BP)) %>% \n  \n  # Calculate cumulative position of each chromosome\n  mutate(tot=cumsum(chr_len)-chr_len) %>%\n  select(-chr_len) %>%\n  \n  # Add this info to the initial dataset\n  left_join(load.df_p, ., by=c(\"CHR\"=\"CHR\")) %>%\n  \n  # Add a cumulative position of each SNP\n  arrange(CHR, BP) %>%\n  mutate( BPcum=BP+tot) \n\n# Prepare X axis\naxisdf <- don %>% group_by(CHR) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )\n\n# Make the plot\nload.p <- ggplot(don, aes(x=BPcum, y=-log10(P))) +\n    \n    # Show all points\n    geom_point( aes(color=as.factor(CHR)), size=0.5) +\n    scale_color_manual(values = rep(c(\"grey50\", \"steelblue\"), 22 )) +\n    \n    # custom X axis:\n    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +\n    scale_y_continuous(expand = c(0, 0) ) +     # remove space between plot area and x axis\n\n    # Add highlighted points\n    # geom_point(data=subset(don, is_highlight==\"yes\"), color=\"orange\", size=2) +\n  \n    # Add label using ggrepel to avoid overlapping\n    # geom_label_repel( data=subset(don, is_annotate==\"yes\"), aes(label=SNP), size=2) +\n\n    # Custom the theme:\n    theme_bw() +\n    labs(title = \"LOAD - Kunkle et al. Nature Genetics 2019\") + \n    theme( \n      legend.position=\"none\",\n      panel.border = element_blank(),\n      panel.grid.major.x = element_blank(),\n      panel.grid.minor.x = element_blank(), \n      axis.title.x = element_blank()\n    )\n\nload.p <- ggman::ggman(load.df_p, snp = \"SNP\", bp = \"BP\", chrom = \"CHR\", pvalue = \"P\", relative.positions = TRUE) + \n  labs(title = \"LOAD - Kunkle et al. Nature Genetics 2019\") + \n  theme_classic()\n  \nggsave(\"results/plots/kunkle2019load_manhattan_plot.png\", height = 4, width = 6, units = 'in')"
  },
  {
    "objectID": "scripts/ancestry.html#prinicpal-component-analysis",
    "href": "scripts/ancestry.html#prinicpal-component-analysis",
    "title": "Genetic Ancestry",
    "section": "Prinicpal Component Analysis",
    "text": "Prinicpal Component Analysis\nTBD\n\nplink \\\n    --keep-allele-order \\\n    --bfile resources/genetic_epi/imputed_1kG_merged \\\n    --fam resources/genetic_epi/imputed_1kG_merged_fixed.fam \\\n    --pca 10 \\\n    --within resources/genetic_epi/1kG_pops.txt \\\n    --pca-clusters resources/genetic_epi/1kG_pops_unique.txt \\\n    --out work/imputed_1kG_merged\n\n\n#!/usr/bin/env Rscript\n\nmessage(\"Loading packages\")\n\nsuppressPackageStartupMessages(library(dplyr))\nlibrary(readr)\nlibrary(magrittr)\nsuppressPackageStartupMessages(library(tidyr))\nlibrary(stringr)\nlibrary(tibble)\nsuppressPackageStartupMessages(library(purrr))\n\n# Get geometric median\n## rdocumentation.org/packages/bigutilsr/versions/0.3.3/topics/geometric_median\n\ngeometric_median <- function(u, tol = 1e-10, maxiter = 1000, by_grp = NULL) {\n  if (!is.null(by_grp))\n    return(do.call(\"rbind\", by(u, by_grp, geometric_median)))\n  u_old <- colMeans(u)\n  for (k in seq_len(maxiter)) {\n    norm <- sqrt(rowSums(sweep(u, 2, u_old, \"-\")^2))\n    u_new <- colSums(sweep(u, 1, norm, \"/\")) / sum(1 / norm)\n    diff <- max(abs(u_new - u_old))\n    if (diff < tol)\n      break\n    u_old <- u_new\n  }\n  if (k == maxiter)\n    warning(\"The maximum number of iterations has been reached.\")\n  u_new\n}\n\n# assign sample to cluster\n## https://www.biorxiv.org/content/10.1101/2020.10.06.328203v2.full\n## adomingues.github.io/2015/09/24/finding-closest-element-to-a-number-in-a-list\n\nfind_cluster <- function(df, clusters) {\n  superpops <- clusters$superpop\n  samp_pcs <- select(df, starts_with(\"PC\"))\n  mat <- bind_rows(clusters, samp_pcs) %>% {suppressWarnings(dist(.))}\n  # mat\n  clus <- which.min(as.matrix(mat)[6, 1:5])\n  dplyr::mutate(df, superpop_infered = superpops[clus])\n}\n\nvec <- 'work/imputed_1kG_merged.eigenvec'\nval <- 'work/imputed_1kG_merged.eigenval'\nbase <- 'resources/genetic_epi/1kG_pops.txt'\ntarget <- 'work/habshd_sampleQC.fam'\noutput <- snakemake@output[[\"excl\"]]\nrmd <- snakemake@output[[\"rmd\"]]\nsample <- 'HABS-HD'\npopulation <- 'all'\nextraref <- snakemake@params[[\"extraref\"]]\nsdev <- snakemake@params[[\"sd\"]]\npcs_out_path <- snakemake@output[[\"pcs_pops\"]]\ntg_pops_file <- 'resources/genetic_epi/tg_subpops.tsv'\n\n\n#load(\"output/ADGC/x_present_AA/ADC8-AA_exclude.pca.params.Rdata\")\n\nif (tolower(population) == \"all\") {\n  all_pops <- T\n} else {\n  all_pops <- F\n}\n\n##---- Read in Data ----##\nmessage(\"Reading data files\")\n\n# count columns and PCs\nn_eig <- count_fields(vec, tokenizer_delim(delim = \" \"), n_max = 1) - 2\n\n# Generate colnames\npc_names <- paste0(\"PC\", 1:n_eig)\nnames_col <- c(\"FID\", \"IID\", pc_names)\n\n# Read in eigenvectors and z-score transform\npca_orig <- read_delim(vec,\n                  delim = \" \", col_names = names_col,\n                  col_types = cols(.default = \"d\", FID = \"c\", IID = \"c\")) %>%\n         mutate_at(pc_names, function(x) as.vector(scale(x)))\n\n# read in egienvalues\neigenval <- val %>%\n  read_lines %>%\n  parse_number %>%\n  tibble(eigenval = .,\n         PC = factor(pc_names, levels = pc_names)) %>% #PC Names\n  mutate(PVE = round(eigenval / sum(eigenval), 3)) %>% #PVE\n  select(PC, eigenval, PVE) #Reorder columns\n\n# population data file, usually from 1000 genomes and potentially with extra ref\nbase_pops_raw <- read_table(base, col_types = cols(.default = \"c\"))\n\n# population data from target set\nfamcols <- c(\"FID\", \"IID\", \"PID\", \"MID\", \"Sex\", \"Pheno\")\ntarget_pops_raw <- read_table(target, col_names = famcols,\n  col_types = \"ccccii\")\n\nmessage(\"Processing data\")\n# ---- Data wrangling ---- #\n\n# Read in populations and superpops\ntg_pops <- read_tsv(tg_pops_file, col_types = \"cccc\")\npopulations <- tg_pops %>% select(pop, spop) %>% deframe %>% as.list\nsuperpops <- unlist(populations) %>% unique()\n\nextra_pops <- base_pops_raw[\n    !(base_pops_raw$Population %in% names(populations)), ] %>%\n  distinct(Population) %>%\n  pull(Population)\n\nif (length(extra_pops) == 1 && extraref == extra_pops) {\n  populations[extraref] <- population\n} else if (length(extra_pops) == 0 && extraref != \"none\") {\n  stop(\"Extra population missing from reference!\")\n} else if (length(extra_pops) > 1) {\n  stop(\"Non-1kG population codes are not yet implemented. Go bug Brian.\")\n}\n\n# Deal with invalid cohort names\n\nif (sample %in% names(populations)) {\n  sample <- paste0(\"s_\", sample)\n}\n\nif (sample %in% populations) {\n  sample_s <- paste0(\"s_\", sample)\n} else {\n  sample_s <- sample\n}\n\n\n##  Munge population dataframes from 1000 genomes\nbase_pops <- base_pops_raw %>%\n  mutate(cohort = \"Reference\",\n         superpop = recode(.$Population, !!!populations))\n\n##  Munge target population dataframes\ntarget_pops <- target_pops_raw %>%\n  select(FID, IID) %>%\n  mutate(Population = sample, superpop = sample_s,\n    cohort = sample_s)\n\n## Check this\nremove_tg <- TRUE\nif (remove_tg) {\n  target_pops <- target_pops %>%\n    filter(!(IID %in% base_pops$IID & FID %in% base_pops$FID))\n}\n\n# fix improperly split FID_IID\npca_fidiid <- pca_orig %>%\n  unite(\"FIDIID\", FID, IID, sep = \"_\")\n\n\n##  Munge PCA, base pop and target pop\nboth_pops <- target_pops %>%\n  bind_rows(base_pops) %>%\n  ##### FIX BAD FID_IID SPLIT #####\n  unite(\"FIDIID\", FID, IID, sep = \"_\", remove = F)\n\npca_corrected <- pca_fidiid %>%\n  left_join(both_pops, by = \"FIDIID\") %>%\n  select(any_of(names(both_pops)), everything(), -FIDIID) %>%\n  mutate(FID = str_remove(FID, \"^1000g___\"))\n\n## Colours for plots\npca_col <- pca_corrected %>%\n  count(superpop) %>%\n  mutate(color = ifelse(superpop == sample_s, \"black\", NA)) %>%\n  mutate(color = ifelse(superpop == \"AFR\", \"#E69F00\", color)) %>%\n  mutate(color = ifelse(superpop == \"AMR\", \"#0072B2\", color)) %>%\n  mutate(color = ifelse(superpop == \"EAS\", \"#009E73\", color)) %>%\n  mutate(color = ifelse(superpop == \"EUR\", \"#CC79A7\", color)) %>%\n  mutate(color = ifelse(superpop == \"NFE\", \"#CC79A7\", color)) %>%\n  mutate(color = ifelse(superpop == \"FIN\", \"#960018\", color)) %>%\n  mutate(color = ifelse(superpop == \"SAS\", \"#D55E00\", color)) %>%\n  mutate(color = ifelse(superpop == \"MID\", \"#56B4E9\", color)) %>%\n  mutate(color = ifelse(superpop == \"AMI\", \"#F0E442\", color))\n\n# ternary plot and assignment:\n\nmessage(\"Ternary Plots\")\n\n# Pull out 1000 genomes samples\nkg <- filter(pca_corrected, cohort == \"Reference\")\n\n# find geometric median of each PC for each cluster\nclusters <-\n  select(kg, starts_with(\"PC\")) %>%\n  geometric_median(by_grp = kg$superpop) %>%\n  as_tibble(rownames = \"superpop\")\n\n# extract sample information and assign to cluster\npca <- pca_corrected %>%\n  group_split(IID) %>%\n  map_df(find_cluster, clusters)\n\nwrite_tsv(pca, pcs_out_path)\n\nreport_settings <- list(\n  all_pops = all_pops,\n  filter_inference = F,\n  filter_sd = F\n)\n\nif (all_pops) {\n  tab_1 <- as.data.frame(clusters)\n  pca_sample <- pca %>%\n    filter(cohort != \"Reference\") %>%\n    mutate(pop_outliers = F)\n  tab_pop_exclusions <- tibble(Exclusions = \"None\")\n} else if (!is.numeric(sdev)) {\n  report_settings$filter_inference <- T\n  tab_1 <- as.data.frame(clusters)\n  pca_sample <- pca %>%\n    filter(cohort != \"Reference\") %>%\n    mutate(pop_outliers = !(superpop_infered %in% population))\n  tab_pop_exclusions <- pca_sample %>%\n    filter(pop_outliers) %>%\n    select(FID, IID, \"Infered Superpopulation\" = superpop_infered)\n} else {\n  report_settings$filter_sd <- T\n  # ---- Population Outliers ---- #\n  # Calculate the mean and ± specified number of sd for each PC of ref pop\n\n  message(\"Table 1\")\n\n  chosen_pca <- pca_corrected %>%\n    gather(key = \"PC\", value = \"eigenvalue\", !!paste0(\"PC\", 1:n_eig)) %>%\n    filter(superpop == population) %>%\n    group_by(superpop, PC) %>%\n    dplyr::summarize(mean = mean(eigenvalue), sd = sd(eigenvalue),\n                     .groups = \"drop\") %>%\n    mutate(lower = mean - sd * sdev, upper = mean + sd * sdev) %>%\n    mutate(PC = factor(PC, levels = paste0(\"PC\", 1:n_eig))) %>%\n    arrange(PC)\n\n  #***Table 1:*** Mean and SD of PC in chosen population\n  tab_1 <- as.data.frame(chosen_pca)\n\n  # For each sample individual, determine if ± specified SD from chosen pop\n  # for each principal component\n\n  message(\"Table 2\")\n\n  pca_range <- function(pc, vals) {\n    lower <- chosen_pca[chosen_pca$PC == pc, \"lower\"] %>% unlist %>% unname\n    upper <- chosen_pca[chosen_pca$PC == pc, \"upper\"] %>% unlist %>% unname\n    sapply(vals, function(x) x < lower | x > upper) %>% as.logical\n  }\n\n  mut_pca <- function(df, pc, pc_use) {\n    pc <- 1:pc\n    pc_use <- paste0(\"PC\", pc, \".outliers\")[1:pc_use]\n    for (i in paste0(\"PC\", pc)) {\n      df %<>% mutate(`!!`(paste0(i, \".outliers\")) := pca_range(i, .[, i]))\n    }\n    dplyr::mutate(df, pop_outliers = rowSums(dplyr::select(df, !!pc_use)) > 0)\n  }\n\n  pca_sample <- pca_corrected %>%\n    filter(superpop == sample_s) %>%\n    mut_pca(n_eig, 10)\n\n  # ***Table 2:*** Population Outliers for each PC\n\n  outlier_cols <- paste0(\"PC\", 1:n_eig, \".outliers\")\n  outlier_cols_rename <- outlier_cols\n  names(outlier_cols_rename) <- paste0(\"PC\", 1:n_eig)\n\n  replace_tf <- function(x) ifelse(x == T, \"Yes\", ifelse(x == F, \"No\", x))\n\n  tab_pop_exclusions <- pca_sample %>%\n    select(FID, IID, !!outlier_cols, pop_outliers) %>%\n    filter(pop_outliers == T) %>%\n    dplyr::rename(!!!outlier_cols_rename) %>%\n    select(-pop_outliers) %>%\n    transmute_all(replace_tf)\n}\n\n# ---- Write out outliers ---- #\n\nno_outliers <- sum(pca_sample$pop_outliers) == 0\nexclude_pop_outliers <- pca_sample %>%\n  filter(pop_outliers == TRUE) %>%\n  select(FID, IID)\n\nwrite_tsv(exclude_pop_outliers, output, col_names = F)\n\nsave(tab_1, tab_pop_exclusions, no_outliers, pca, pca_sample, eigenval,\n     pca_col, sdev, report_settings, file = rmd)"
  },
  {
    "objectID": "scripts/ancestry.html#admixture",
    "href": "scripts/ancestry.html#admixture",
    "title": "Genetic Ancestry",
    "section": "ADMIXTURE",
    "text": "ADMIXTURE\nTBD\n\nadmixture -P -s 42 habshd_merged_gnomad-hgdp-1kg.hg38.bed 12 -j1"
  },
  {
    "objectID": "scripts/prs.html",
    "href": "scripts/prs.html",
    "title": "Polygenic Risk Scores",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee1 for additional discussion of literate programming.\n\n\n\n\n1. Knuth DE. Literate programming. Comput J. 1984;27(2):97-111."
  },
  {
    "objectID": "scripts/mr.html",
    "href": "scripts/mr.html",
    "title": "Mendelian Randomization",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "scripts/references.html",
    "href": "scripts/references.html",
    "title": "References",
    "section": "",
    "text": "1. Knuth DE. Literate programming.\nComput J. 1984;27(2):97-111.\n\n\n2. Purcell S, Neale B, Todd-Brown K, et al. PLINK: A Tool\nSet for Whole-Genome Association and Population-Based Linkage\nAnalyses. The American Journal of Human Genetics.\n2007;81(3):559-575.\n\n\n3. Danecek P, Bonfield JK, Liddle J, et al. Twelve years of SAMtools and BCFtools.\nGigaScience. 2021;10(2):giab008.\n\n\n4. Murphy AE, Schilder BM, Skene NG. MungeSumstats: A Bioconductor package for the\nstandardisation and quality control of many GWAS summary\nstatistics. Bioinformatics.\n2021;37(23):btab665-.\n\n\n5. Bulik-Sullivan B, Finucane HK, Anttila V, et\nal. An\natlas of genetic correlations across human diseases and\ntraits. Nature Genetics.\n2015;47(11):1236-1241.\n\n\n6. Ning\nZ, Pawitan Y, Shen X. High-definition likelihood inference of genetic\ncorrelations across human complex traits. Nature\nGenetics. 2020;52(8):859-864.\n\n\n7. Grotzinger AD, Rhemtulla M, Vlaming R de, et\nal. Genomic structural equation modelling provides insights\ninto the multivariate genetic architecture of complex traits.\nNature human behaviour. 2019;3(5):513-525.\n\n\n8. Choi\nSW, O’Reilly PF. PRSice-2: Polygenic Risk Score software for biobank-scale\ndata. GigaScience. 2019;8(7).\n\n\n9. Choi\nSW, García-González J, Ruan Y, et al. PRSet: Pathway-based polygenic risk score analyses and\nsoftware. PLOS Genetics. 2023;19(2):e1010624.\n\n\n10. Alexander DH, Novembre J, Lange K. Fast\nmodel-based estimation of ancestry in unrelated individuals.\nGenome Research. 2009;19(9):1655-1664.\n\n\n11. Maples BK, Gravel S, Kenny EE, Bustamante CD.\nRFMix: A Discriminative Modeling Approach for Rapid and\nRobust Local-Ancestry Inference. The American Journal of\nHuman Genetics. 2013;93(2):278-288.\n\n\n12. Ruan Y, Lin YF, Feng YCA, et al. Improving polygenic prediction in ancestrally diverse\npopulations. Nature Genetics.\n2022;54(5):573-580.\n\n\n13. Hemani G, Zheng J, Elsworth B, et al. The\nMR-Base platform supports systematic causal inference across the human\nphenome. eLife. 2018;7:e34408."
  }
]